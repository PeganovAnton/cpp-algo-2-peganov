Сравнение синтаксиса Python и С++
#################################

:date: 2020-02-05 09:00
:summary: Базовый синтаксис языка С++.
:lecture_link: https://youtu.be/6KolmHZqjXI
:status: published

.. default-role:: code
.. contents:: Содержание


Принцип раздельной компиляции
=============================

Компиляция — алгоритмически сложный процесс, для больших программных проектов требующий существенного времени и вычислительных возможностей ЭВМ. Благодаря наличию в процессе сборки программы этапа компоновки (связывания) возникает возможность *раздельной компиляции*.

В модульном подходе программный код разбивается на несколько файлов `.cpp`, каждый из которых компилируется отдельно от остальных.

Это позволяет значительно уменьшить время перекомпиляции при изменениях, вносимых лишь в небольшое количество исходных файлов. Также это даёт возможность замены отдельных компонентов конечного программного продукта, без необходимости пересборки всего проекта.


Пример модульной программы с раздельной компиляцией на С++
==========================================================

Рассмотрим пример: есть желание вынести часть кода в отдельный файл — пользовательскую библиотеку.

program.cpp
-----------

.. code-include:: code/lab1/program.cpp
    :lexer: cpp

Подключение пользовательской библиотеки в С++ на самом деле не так просто, как кажется.

Сама библиотека должна состоять из двух файлов: `mylib.hpp` и `mylib.cpp`:

mylib.hpp
---------

.. code-include:: code/lab1/mylib.hpp
    :lexer: cpp

mylib.cpp
---------

.. code-include:: code/lab1/mylib.cpp
    :lexer: cpp

Препроцессор С++, встречая `#include "mylib.hpp"`, полностью копирует содержимое указанного файла (как текст) вместо вызова директивы. Благодаря этому на этапе компиляции не возникает ошибок типа Unknown identifier при использовании функций из библиотеки.

Файл `mylib.cpp` компилируется отдельно.

А на этапе компоновки полученный файл `mylib.o` должен быть включен в исполняемый файл `program`.

Cреда разработки обычно скрывает весь этот процесс от программиста, но для корректного анализа ошибок сборки важно представлять себе, как это делается.

Упражнение №4
-------------

Давайте сделаем это руками:

.. code-block:: bash

    $ g++ -c mylib.cpp                      # 1
    $ g++ -c program.cpp                    # 2
    $ g++ -o program mylib.o program.o      # 3

Теперь, если изменения коснутся только `mylib.cpp`, то достаточно выполнить только команды 1 и 3.
Если только program.cpp, то только команды 2 и 3.
И только в случае, когда изменения коснутся интерфейса библиотеки, т.е. заголовочного файла `mylib.hpp`, придётся перекомпилировать оба объектных файла.

Утилита make и Makefile
=======================

Утилита `make` предназначена для автоматизации преобразования файлов из одной формы в другую.
По отметкам времени каждого из имеющихся объектных файлов (при их наличии) она может определить, требуется ли их пересборка.

Правила преобразования задаются в скрипте с именем `Makefile`, который должен находиться в корне рабочей директории проекта. Сам скрипт состоит из набора правил, которые в свою очередь описываются:

1) целями (то, что данное правило делает);
2) реквизитами (то, что необходимо для выполнения правила и получения целей);
3) командами (выполняющими данные преобразования).

В общем виде синтаксис Makefile можно представить так:

.. code-block:: text

    # Отступ (indent) делают только при помощи символов табуляции,
    # каждой команде должен предшествовать отступ
    <цели>: <реквизиты>
        <команда #1>
        ...
        <команда #n>

То есть, правило make это ответы на три вопроса:

    {Из чего делаем? (реквизиты)} ---> [Как делаем? (команды)] ---> {Что делаем? (цели)}

Несложно заметить что процессы трансляции и компиляции очень красиво ложатся на эту схему:

    {исходные файлы} ---> [трансляция] ---> {объектные файлы}

    {объектные файлы} ---> [линковка] ---> {исполнимые файлы}

Простейший Makefile
-------------------

Для компиляции `hello.cpp` достаточно очень простого мэйкфайла:

.. code-block:: make

    hello: hello.cpp
        gcc -o hello hello.cpp

Данный Makefile состоит из одного правила, которое в свою очередь состоит из цели — `hello`, реквизита — `hello.cpp`, и команды — `gcc -o hello hello.cpp`.

Теперь, для компиляции достаточно дать команду `make` в рабочем каталоге. По умолчанию `make` станет выполнять самое первое правило, если цель выполнения не была явно указана при вызове:

    $ make <цель>

Makefile для модульной программы
--------------------------------

.. code-block:: make

    program: program.o mylib.o
            g++ -o program program.o mylib.o

    program.o: program.cpp mylib.hpp
            g++ -c program.cpp

    mylib.o: mylib.cpp mylib.hpp
            g++ -c hylib.cpp


Попробуйте собрать этот проект командой `make` или `make hello`.
Теперь измените любой из файлов `.cpp` и соберите проект снова. Обратите внимание на то, что во время повторной компиляции будет транслироваться только измененный файл.

После запуска `make` попытается сразу получить цель `program`, но для ее создания необходимы файлы `program.o` и `mylib.o`, которых пока еще нет. Поэтому выполнение правила будет отложено и `make` станет искать правила, описывающие получение недостающих реквизитов. Как только все реквизиты будут получены, `make`вернется к выполнению отложенной цели. Отсюда следует, что `make` выполняет правила рекурсивно.

Фиктивные цели
--------------

На самом деле в качестве make целей могут выступать не только реальные файлы. Все, кому приходилось собирать программы из исходных кодов, должны быть знакомы с двумя стандартными в мире UNIX командами:

.. code-block:: bash

    $ make
    $ make install

Командой make производят компиляцию программы, командой `make install` — установку. Такой подход весьма удобен, поскольку все необходимое для сборки и развертывания приложения в целевой системе включено в один файл (забудем о скрипте `configure`). Обратите внимание на то, что в первом случае мы не указываем цель, а во втором целью является вовсе не создание файла `install`, а процесс установки приложения в систему. Проделывать такие фокусы нам позволяют так называемые фиктивные (phony) цели. Вот краткий список стандартных целей:

    all — является стандартной целью по умолчанию. При вызове make ее можно явно не указывать;
    clean — очистить каталог от всех файлов полученных в результате компиляции;
    install — произвести инсталляцию;
    uninstall — и деинсталляцию соответственно.


Для того чтобы make не искал файлы с такими именами, их следует определить в `Makefile`, при помощи директивы `.PHONY`. Далее показан пример `Makefile` с целями `all`, `clean`, `install` и `uninstall`:

.. code-include:: code/lab1/Makefile
    :lexer: make

Теперь мы можем собрать нашу программу, произвести ее инсталляцию/деинсталляцию, а так же очистить рабочий каталог, используя для этого стандартные make цели.

Обратите внимание на то, что в цели `all` не указаны команды; все что ей нужно — получить реквизит `program`. Зная о рекурсивной природе make, не сложно предположить, как будет работать этот скрипт. Также следует обратить особое внимание на то, что если файл `program` уже имеется (остался после предыдущей компиляции) и его реквизиты не были изменены, то команда `make` ничего не станет пересобирать. Это классические грабли make. Так, например, изменив заголовочный файл, случайно не включенный в список реквизитов (а надо включать!), можно получить долгие часы головной боли. Поэтому, чтобы гарантированно полностью пересобрать проект, нужно предварительно очистить рабочий каталог:

.. code-block:: bash

    $ make clean
    $ make

P.S. Неплохая `статья`__ с описанием мейкфайлов.

.. __: https://habrahabr.ru/post/155201/

Шаблоны
=======

Шаблоны - это расширение языка (в данном случае расширение языка C++ по отношению к языку C), позволяющее автоматизировать работу программиста. С шаблонами уменьшается количество написанного кода, если нужно реализовать аналогичный функционал для различных исходных типов. Например, есть функция, и она должна работать для параметров разного типа. Конечно, можно написать несколько разных функций, или воспользоваться перезагрузкой функций, но шаблоны предоставляют альтернативный путь. Т. е. для функции (или класса) имеется некий формализованный код (шаблон), в который передаются типы, и компилятор на основе этого сам строит рабочий код. 

Рассмотрим применение шаблонов на примере функции `max`. На языке C ее можно реализовать при помощи директивы `#define` препроцессора

.. code-block:: c

    #define max(a,b)    ((a)>(b) ? (a) : (b))

Теперь везде, где нужно найти большое из двух значений можно использовать определенный выше макрос:

.. code-block:: c

    int x = 1;
    int y = 2;
    int z = max(x, y); // z = 2

При использовании макросов следует избегать передачи выражений в качестве аргументов, иначе возможно непредсказуемое поведение. Скомпилируйте код, приведенный ниже и попробуйте обьяснить полученные результаты:

.. code-block:: c

    #include <iostream>

    #define max(a,b)	((a)>(b) ? (a) : (b))
    int main() {
        int x = 1;
        int y = 2;
        int z = max(x++, y++); 
        std::cout << x << ' ' << y << ' ' << z << std::endl;
    }

Шаблоны в C++ - это инструкции, согласно которым создаются локальные версии шаблонированной функции (или класса/структуры) для определенного набора параметров и типов данных.

С использованием шаблонов определение max будет выглядеть так:

.. code-block:: c

    template <typename T> 
    T & max(const T & a, const T & b) {
        return a > b ? a : b;
    }

каждое использование шаблона в коде с новым типом вызовет генерацию компилятором функции с заданным типом. Например:

.. code-block:: c

    int xi = 1;
    int yi = 2;
    int zi = max(xi, yi); // будет сгенерирована и скомпилирвоана функция max(const int & a, const int & b)

    float xf = 1.0f;
    float yf = 2.0f;
    float zf = max(xf, yf); // будет сгенерирована и скомпилирована функция max(const float & a, const float & b)

Использование шаблонов позволяет сократить обьем написанного кода в случае когда одни и те же алгоритмы нужно применить для разных типов данных.

Шаблоны также применяются и при создании классов. Допустим, в программе нужно реализовать два односвязных списка - для строк и целых чисел.

В первом случае каждый узел будет будет описываться структурой 

.. code-block:: c

    struct tNode {
        std::string data;
        tNode* next;
    }; 

во втором 

.. code-block:: c

    struct tNode {
       int data;
       tNode* next;
    }; 


очевидно, что алгоритмы работы над элементами списка не зависят от типа хранимых значений (в данном случае типа поля `data`). Поэтому структуру `tNode` можно описать в виде шаблона:

.. code-block:: c

    template<typename DataType>
    struct tNode {
        DataType data;
        tNode<T>* next;
    };


Обьявление односвязного списка будет выглядеть так:

.. code-block:: c

    template<typename DataType>
    struct List {
       tNode<DataType>* begin;
       int size;
    };


соотвественно функции, выполняющие различные действия над элементами списка тоже должны быть обьявлены как шаблоны:

.. code-block:: c

    template<typename DataType>
    void list_init(List<DataType> & lst)
    {
        lst.begin = nullptr;
        lst.size = 0;
    }

Обьявление переменных будет выглядеть следующим образом:

.. code-block:: c

    List<std::string> stringList;
    List<int> intList;

На стадии компиляции из шаблонов будут сгенерированы структуры `tNode` и `List` соотвествующие типам `std:string` и `int`.


Односвязанный список
====================

Структура `List`, обьявленая выше, содержит указатель на первый элемент списка `begin` и кол-во элементво в списке - `size`. Данная реализация позволяет достаточно просто добавлять элементы в начало списка, поскольку указатель на первый элемент  известен (поле `begin`). Но чтобы добавить элемент в конец, нужно циклом пробежать по всему списку, пока не будет найден последний элемент. 
Другими словами, данная реализация позволяет за `O(1)` операций вставлять элементы в начало и вычислять длину списка (поскольку кол-во элементов хранится в переменной `size`), но при добавлении в конец уже потребуется `O(n)`.

Задание
-------

* Скачайте `заголовочный файл`__ и `пример его использования`__ . Скомпилируйте и запустите программу. 

.. __: ../code/lab18/linked_list.hpp
.. __: ../code/lab18/list_app.cpp

* Добавьте поле `end` в структуру `List`, модифицируйте функции, работающие со списком чтобы они корректно заполняли значение этого поля. 
* Реализуйте функцию `list_insert_back`, вставляющую элементы в конец списка. Добавьте цикл, который вставляет числа от 90 до 100 в конец списка.
* Реализуйте функцию `list_insert(List<DataType> & l, int i)`, вставляющую элемент в `i` позицию списка. Вставьте значение -1 в серидину списка.

.. image:: {filename}/images/lab18/insert.png
   :width: 50%


.. |swap_img| image:: {filename}/images/lab18/swap.png
   :width: 50%


.. |swap_1_img| image:: {filename}/images/lab18/swap1.png
   :width: 75%


* Реализуйте функцию bool `list_swap(List<DataType> & l, int i, int j)`` меняющую местами `i` и `j` элементы списка и возвращаующую `true`. Если `i` или `j` выходят за границы списка, функция должна возвращать `false` и не менять содержимое списка. При этом нужно учесть, что возможны два варианта: 

    * заменяемые узлы являются соседями 

|swap_img|

    * заменяемые узлы не являются соседями, то есть между ними имеется хотя бы один элемент 

|swap_1_img|


* Реализуйте функцию ``bool list_remove(List<DataType> & l, int i)`` удаляющую `i` элемент списка и возвращающую `true`. Если `i` выходит за границы списка, то функция должна возвращать `false` и не менять содержимое списка. Удалите все четные числа из списка.

.. image:: {filename}/images/lab18/remove.png
   :width: 37%

* Реализуйте функцию `void list_reverse(List<DataType> & l)` которая располагает элементы исходного списка в обратном порядке. Выведите на экран сначаал исходный список, а потом перевернутый.
* Реализуйте функцию `void list_sort(List<DataType> & l)` которая сортирует элементы исходного списка в порядке возрастания используя сортировку пузырьком. Выведите на экран содержимое отсортированного списка.


Классы в C++
============

Подробнее в лекции https://www.youtube.com/watch?v=tDKgIPHapsg

Класс -- это пользовательский тип, который позволяет удобно объединить данные и функции для работы с этими данными. Переменные, являющиеся частью класса, называют **полями** (их также называют **признаками**, **переменными-членами**), а функции, входящие в класс, называют **методами** (также встречается название **функции-члены**). Хороший пример -- класс ``std::string``, который имитирует строку. ``std::string`` содержит в себе массив символов и полезные инструменты для работы с этим массивом, например метод ``find``, который возвращает индекс некоторого символа в массиве.

Ниже приведен пример программы, использующей класс. Скомпилируйте и запустите ее.

.. code-block:: c

    #include <iostream>
    #include <string>


    enum Mood {nice, angry};


    class Dog
    {
    private:
        Mood mood;
        std::string dog_name;
    public:
        // Это специальная функция, которая называется конструктором. 
        // Она вызывается при создании объекта и используется для инициализации 
        // признаков объекта.
        Dog(std::string dog_name_)
        {
            mood = nice;
            dog_name = dog_name_;
        }

        Dog()
        {
            mood = nice;
            dog_name = "Zhuchka";
        }

        void poke()
        {
            std::cout << "<You poked the dog with a stick>\n";
            mood = angry;
        }

        void say_gaw()
        {
            if (mood == nice)
                std::cout << "Gaw! :)\n";
            else
                std::cout << "GAWGAW!!!\n";
        }
    
        void feed()
        {
            std::cout << "<You fed the dog with a delicious stake>\n";
            mood = nice;
        }
 
        std::string what_is_your_name()
        {
            return dog_name;
        }
    };


    int main()
    {
        Dog dog;
        dog.say_gaw();
        dog.poke();
        dog.say_gaw();
        dog.feed();
        dog.say_gaw();
        std::cout << "The dog name is " << dog.what_is_your_name() << std::endl;
  
        Dog dog2("Kashtanka");
        std::cout << "The 2nd dog name is " << dog2.what_is_your_name() << std::endl;

    }


У данного класс есть 2 поля: ``name`` и ``mood`` и 4 метода не считая конструктора: ``poke``, ``say_gaw``, ``feed``, ``what_is_your_name``. Чтобы получить поле или метод класса используют оператор ``.``. Если дан указатель на класс, то вместо ``.`` используется оператор ``->``.

.. code-block:: c

    int main()
    {
        Dog *dog;
        dog->say_gaw();
    }


Конструктор класса -- это специальный метод, который используется для инициализации объектов класса. При объявлении и определении конструктора не указывается тип возвращемого значения, а имя конструктора должно совпадать с именем класса.


Объединение данных с функциями (инкапсуляция) выражается в том, что внутри метода класса видны все остальные члены класса (поля и методы). Например, в методе ``poke`` доступно поле ``mood``. Если имя локальной переменной в методе совпадает с именем поля класса, то поле класса можно получить с помощью специальной переменной ``this``, которая доступна внутри каждого класса и являет указателем на текущий объект. Например, если бы аргумент конструктора назывался ``dog_name`` определение конструктора бы выглядело так.

.. code-block:: c

    class Dog
    { 
    std::string dog_name;
    ...
    public:
        Dog(std::string dog_name)
        {
            mood = nice;
            this->dog_name = dog_name;
        }
    ...
    };



Можно разделить объявление и реализацию класса. Заголовочный файл *dog.h* будет выглядеть тривиально.


.. code-block:: c

    class Dog
    {
        private:
            Mood mood;
            std::string dog_name;
        public:
            Dog();
            Dog(std::string dog_name);
            void poke();
            void say_gaw();
            void feed();
            std::string what_is_your_name();
    }

В исходнике *dog.cpp* слово ``class`` не нужно использовать, но перед реализацией методов нужно указывать имя ``Dog``.

.. code-block:: c

    #include "dog.h"

    Dog::Dog()
    {
        mood = nice;
        dog_name = "Zhuchka";
    }
    ...
   
    void Dog::poke()
    {
        std::cout << "<You poked the dog with a stick>\n";
        mood = "angry";
    }
    ...

Ключевые слова ``private`` и ``public`` -- это модификаторы доступа. Члены класса, объявленные после слова ``public`` доступны извне по операторам ``.`` и ``->``. Публичные члены класса образуют его **интерфейс**. Члены класса, объявленые после ключевого слова ``private`` доступны только внутри методов класса. Разделение членов класса на публичные и приватные повышает безопасность кода (не дает случайно сломать объект) и позволяет создавать интерфейсы между частями программы. Если модификатор доступа не указан, то член будет приватным.

Объект класса в памяти программы очень похож на переменную типа ``struct``, то есть занимает место в памяти необходимое, чтобы поместились поля объекта. Код методов хранится отдельно и при присваивании не копируется. Структура отличает от класса тем, что поля структуры по умолчанию публичные, а не приватные.


Перегрузка операторов в C++
===========================
С++ позволяет организовать перегрузку операций. Механизм перегрузки операций позволяет обеспечить более традиционную и удобную запись действий над объектами. Для перегрузки встроенных операторов используется ключевое слова operator.
Синтаксически перегрузка операций осуществляется следующим образом:

.. code-block:: c

	тип operator @ (список_параметров-операндов)
	{
	// ... тело функции ...
	}

где @ — знак перегружаемой операции (-, +, *  и т. д.),
тип — тип возвращаемого значения.
Операторы бывают бинарные (например, a+b) и унарные (например, i++).

Рассмотрим следующий код:


.. code-block:: c

	#include <iostream>
	class Point2D {
		int x, y;
		
		public:
			Point2D() : x(0), y(0) {}
			Point2D( int _x, int _y ) : x(_x), y(_y) {}
			Point2D operator+(const Point2D & t) { return Point2D(x+t.x, y+t.y); }
			Point2D operator=(const Point2D & t) { x = t.x; y = t.y; return* this; }
			void show () { std::cout << x << ", " << y << std::endl; }
	};
	
	int main() {
		Point2D a(1, 2), b(10, 10), c;
		a.show();
		b.show();
		c = a+b;
		c.show();
		c = a+b+c; 
		c.show();
		c = b = a; 
		c.show();
		b.show ();
		return 0;	
	}


Эта программа выводит на экран следующие числа:

.. code-block:: c

	1, 2
	10, 10
	11, 12
	22, 24
	1, 2
	1, 2


обе функции-опе­ратора имеют только по одному параметру, несмотря на то, что они перегружают бинарный оператор. Это связано с тем, что при перегрузке бинарного оператора с использованием функции класса ей передается явным образом только один аргумент. Вторым аргументом служит ука­затель this, который передается ей неявно. Так, в строке


.. code-block:: c

	Point2D operator+(const Point2D & t) { return Point2D(x+t.x, y+t.y); };


х соответствует this->x, где х ассоциировано с объектом, который вызывает функцию-оператор. Во всех случаях именно объект слева от знака операции вызывает функцию-оператор. Объект, стоящий справа от знака операции, передается функции. 

.. code-block:: c

	a + b эквивалентно вызову a.operator+(b)


При перегрузке унарной операции функция-оператор не имеет параметров, а при перегрузке бинарной операции функция-оператор имеет один параметр. (Нельзя перегрузить триадный опе­ратор ?:.) Во всех случаях объект, активизирующий функцию-оператор, передается неявным об­разом с помощью указателя this.

Чтобы понять, как работает перегрузка операторов, тщательно проанализируем, как работа­ет предыдущая программа, начиная с перегруженного оператора +. Когда два объекта типа Point2D подвергаются воздействию оператора +, значения их соответствующих координат скла­дываются, как это показано в функции operator+(), ассоциированной с данным классом. Обра­тим, однако, внимание, что функция не модифицирует значений операндов. Вместо этого она возвращает объект Point2D, содержащий результат выполнения операции. Чтобы понять, почему оператор + не изменяет содержимого объектов, можно представить себе стандартный арифметический оператор +, примененный следующим образом: 10 + 12. Результатом этой опе­рации является 22, однако ни 10 ни 12 от этого не изменились. Хотя не существует правила о том, что перегруженный оператор не может изменять значений своих операндов, обычно име­ет смысл следовать ему. Если вернуться к данному примеру, то нежелательно, чтобы оператор + изменял содержание операндов.

Другим ключевым моментом перегрузки оператора сложения служит то, что он возвращает объект типа Point2D. Хотя функция может иметь в качестве значения любой допустимый тип язы­ка С++, тот факт, что она возвращает объект типа Point2D, позволяет использовать оператор + в более сложных выражениях, таких, как a+b+с. Здесь а+b создает результат типа Point2D. Это значение затем прибавляется к с. Если бы значением суммы а+b было значение другого типа, то мы не могли бы затем прибавить его к с.

В противоположность оператору +, оператор присваивания модифицирует свои аргументы. (В этом, кроме всего прочего, и заключается смысл присваивания.) Поскольку функция operator=() вызывается объектом, стоящим слева от знака равенства, то именно этот объект модифицируется при выполнении операции присваивания. Однако даже оператор присваивания обязан возвра­щать значение, поскольку как в С++, так и в С оператор присваивания порождает величину, стоящую с правой стороны равенства. Так, для того, чтобы выражение следующего вида

.. code-block:: c

	а = b = с = d;


было допустимым, необходимо, чтобы оператор operator=() возвращал объект, на который ука­зывает указатель this и который будет объектом, стоящим с левой стороны оператора присваива­ния. Если сделать таким образом, то можно выполнить множественное присваивание.

Можно перегрузить унарные операторы, такие как ++ или --. Как уже говорилось ранее, при перегрузке унарного оператора с использованием функци класса, эта функция-член не имеет аргументов. Вместо этого операция выполняется над объектом, осуществляющим вызов функции-оператора путем неявной передачи указателя this. Добавим оператор инкремента для объекта типа Point2D:

.. code-block:: c

	Point2D & operator++ () { x++; y++; return *this; }
	Point2D operator++ (int d) { Point2D p(x,y); ++(*this); return p; }


Если ++ предшествует операнду, то вызывается функция operator++() (префиксный оператор). Если же ++ следует за операндом, то тогда вызывается функция operator++(int d), где d принимает значение 0 (постфиксный оператор). Правилом хорошего тона считается использование префиксного оператора в постфиксном.


Два способа перегрузки операторов
=================================

Функция-оператор может быть другом класса (friend), а не только его функцией. Поскольку функции-друзья не являются функциями класса, они не могут иметь неявный аргумент this. Поэтому при использовании дружественной функции-оператора оба операнда пе­редаются функции при перегрузке бинарных операторов, а при перегрузке унарных операторов передается один операнд.
Следующие операторы не могут использовать перегрузку с помощью функций-друзей: =, (), [], и ->. Остальные операторы могут быть перегружены как с помощью функций-классов, так с помощью функций-друзей. 
В качестве примера ниже рассматрим мо­дифицированную версия класса Point2D, в которой оператор + перегружен с помощью дружественной функции:

.. code-block:: c

	#include <iostream>
	class Point2D {
		int x, y;

		friend Point2D operator+(const Point2D & a, const Point2D & b);

		public:
			Point2D() : x(0), y(0) {}
			Point2D( int _x, int _y ) : x(_x), y(_y) {}
			Point2D operator=(const Point2D & t) { x = t.x; y = t.y; return *this; }
			void show () { std::cout << x << ", " << y << std::endl; }
	};
	
	Point2D operator+(const Point2D & a, const Point2D & b) { return Point2D(a.x+b.x, a.y+b.y); }

	int main() {
		Point2D a(1, 2), b(10, 10), c;
		a.show();
		b.show();
		c = a+b;
		c.show();
		c = a+b+c; 
		c.show();
		c = b = a; 
		c.show();
		b.show ();
		return 0;	
	}

В данном случае оба операнда передаются функции operator+(). Левый опе­ранд передается в переменной a, а правый — в переменной b.

Во многих случаях использование функций-друзей вместо функций-класса не дает выигрыша при перегрузке операторов. Однако имеется одна ситуация, в которой необходимо использо­вать дружественные функции. Как известно, указатель на объект, вызывающий функцию-оператор, передается в указателе this. В случае бинарных операторов левый объект вызывает эту фун­кцию. Такой способ работает до тех пор, пока левый объект определяет заданную операцию. Предположим, что для объекта X определены операции присваивания и сложения, так что следующий код

.. code-block:: c

	X = X + 2; // будет работать


является корректным. Поскольку объект X находится с левой стороны оператора+, то он вызы­вает оператор-функцию, перегружающую операцию сложения, которая по предположению спо­собна добавить целое число к определенному элементу объекта О. Однако следующая инструкция не является корректной:

.. code-block:: c
	
	X = 2 + X; // не будет работать

Причина, по которой эта инструкция не будет выполняться, заключена в том, что слева от опера­тора + теперь стоит целое число, являющееся встроенным типом и не имеет функции, кото­рая могла бы осуществить сложение с объектом X. Для решения данной проблемы необходимо определить два оператора сложения:

.. code-block:: c
	
	X operator+(X & x, int i);
	X operator+(int i, X & x);

В зависимости от порядка операндов в выражении будет вызываться подходящий оператор.


Правила перегрузки операций
===========================

Язык C++ не допускает определения для операций нового лексического символа, кроме уже определенных в языке. Например, нельзя определить в качестве знака операции @.
Не допускается перегрузка операций для встроенных типов данных. Нельзя, например, переопределить операцию сложения целых чисел:


.. code-block:: c

	int operator +(int i, int j);

* Нельзя переопределить приоритет операции.
* Нельзя изменить синтаксис операции в выражении. Например, если некоторая операция определена как унарная, то ее нельзя определить как бинарную. Если для операции используется префиксная форма записи, то ее нельзя переопределить в постфиксную. Например, !а нельзя переопределить как а!
* Перегружать можно только операции, для которых хотя бы один аргумент представляет тип данных, определенный пользователем. Функция-операция должна быть определена либо как функция-член класса, либо как внешняя функция, но дружественная классу.


Следующие операторы могут быть переопределены:

+--------+--------+--------+---------+---------+--------+--------+--------+--------+--------+
| ``+``  | ``*``  | ``/``  | ``%``   | ``^``   | ``&``  | ``\``  | ``|``  | ``~``  | ``!``  |
+--------+--------+--------+---------+---------+--------+--------+--------+--------+--------+
| ``=``  | ``<``  | ``>``  | ``+=``  | ``-=``  | ``*=`` | ``/=`` | ``%=`` | ``^=`` | ``&=`` |
+--------+--------+--------+---------+---------+--------+--------+--------+--------+--------+
| ``|=`` | ``<<`` | ``>>`` | ``>>=`` | ``<<=`` | ``==`` | ``!=`` | ``<=`` | ``>=`` | ``&&`` |
+--------+--------+--------+---------+---------+--------+--------+--------+--------+--------+
| ``||`` | ``++`` | ``--`` | ``[]``  | ``()``  | new    | delete |        |        |        |
+--------+--------+--------+---------+---------+--------+--------+--------+--------+--------+


Класс Fraction
==============

Рассмотрим класс Fraction, реализующий базовый функционал над дробями:

.. code-block:: c

	#include <iostream>
	#include <stdexcept>
	#include <cstdlib>
	#include <cmath>

	class Fraction {
		private:
			int numerator;
			int denominator;
			
			void simplify() {
				if (denominator < 0) {
					numerator *= -1;
					denominator *= -1;
				}
				if ( abs(numerator) < 2 ) return;
				int gcd = getGCD( abs(numerator), denominator );
				numerator /= gcd;
				denominator /= gcd;
			}
		public:
			Fraction( int n, int d ) : numerator(n), denominator(d) {
				simplify();
			}

			Fraction() : numerator(0), denominator(1) {}
			Fraction( const Fraction &other ) : numerator( other.getNumerator() ), denominator( other.getDenominator() ) {}

			Fraction( int value ) : numerator(value), denominator(1) {}

			int getNumerator() const { return numerator; }
			int getDenominator() const { return denominator; }
			
			double getValue() const {
				return static_cast<double>(getNumerator()) / static_cast<double>(getDenominator());
			}

			int compareTo( const Fraction &other ) const {
				return getNumerator() * other.getDenominator() - getDenominator() * other.getNumerator();
			}

			int getGCD( int a, int b ) {
				while( a != b ) {
					if (a > b) a -= b; else b -= a;
				}
				return a;
			}

			Fraction operator-() {
				return Fraction(-getNumerator(), getDenominator());
			}

			Fraction operator+(const Fraction &a) {
				int commonDenominator = a.getDenominator() * getDenominator();
				int commonNumerator = a.getNumerator() * getDenominator() + getNumerator() * a.getDenominator();
				return Fraction(commonNumerator, commonDenominator);
			}

			Fraction operator*(const Fraction &a) {
				return Fraction(getNumerator() * a.getNumerator(), getDenominator() * a.getDenominator());
			}

			Fraction operator/(const Fraction &a) {
				return Fraction(getNumerator() * a.getDenominator(), getDenominator() * a.getNumerator());
			}

			bool operator==(const Fraction &a) { return compareTo(a) == 0; }
	};

	std::ostream &operator<<(std::ostream &stream, const Fraction& a) {
		return stream << a.getNumerator() << "/" << a.getDenominator();
	}

	Fraction power(const Fraction &fraction, int power) {
		return (power < 0) ?
				Fraction((int)pow(fraction.getDenominator(), -power), (int)pow(fraction.getNumerator(), -power)) :
				Fraction((int)pow(fraction.getNumerator(), power), (int)pow(fraction.getDenominator(), power));
	}

	int main(int argc, char **argv) {
		Fraction a(-4, 7), b(1, 3), c(0, 4);
		std::cout << c << " " << a * c << std::endl;
		std::cout << (a < b) << " " << power(Fraction(1, 4), -1) << std::endl;
	}

Скопируйте и запустите код, приведенный выше, и убедитесь, что он работает корректно.



Упражнение №1
-------------

Разделите код на файлы *main.cpp*, *fraction.hpp* и *fraction.cpp* и для напишите *Makefile* для сборки проекта.


Упражнение №2
-------------

Добавьте в класс ``Fraction`` метод ``print``. Например, если числитель равен 1, а знаменатель 3, то метод ``print`` должен печатать строку ``"1/3"``.

Добавьте в класс метод ``reciprocal``, который будет возвращать обратную дробь. Например, вызванный от ``Fraction(1, 3)`` этот метод вернет дробь, равную ``Fraction(3, 1)``. 


Упражнение №2
-------------

Реализуйте следующие операторы для класса Fraction:

.. code-block:: c

	bool operator<(const Fraction &a)
	bool operator>(const Fraction &a)
	bool operator<=(const Fraction &a)
	bool operator>=(const Fraction &a)


Упражнение №3
-------------

Реализуйте оператор 

.. code-block:: c

	Fraction operator-(Fraction &a) 

не обращаясь явно к полям numerator и denominator


Упражнение №4
-------------

Реализуйте основные арифметические операторы (+,-,*,/) для Fraction и int.
